#!/usr/bin/env python

from kubepy import api as kubectl
import json
import base64
import subprocess
import json
import re

print("\nsyncing pods and images against local and remote registry\n")

print("\nfetching pods, current repodigest and image name")

image2digest2pods = {}
for pod in kubectl.get("pods")["items"]:
    image_name = pod["status"]["containerStatuses"][0]["image"]
    digest = re.sub("^.*@", "", pod["status"]["containerStatuses"][0].get("imageID", ""))

    if not image_name in image2digest2pods:
        image2digest2pods[image_name] = {}
    if not digest in image2digest2pods[image_name]:
        image2digest2pods[image_name][digest] = []

    image_name = pod["status"]["containerStatuses"][0]["image"]
    digest = re.sub("^.*@", "", pod["status"]["containerStatuses"][0].get("imageID", ""))

    if not image_name in image2digest2pods:
        image2digest2pods[image_name] = {}
    if not digest in image2digest2pods[image_name]:
        image2digest2pods[image_name][digest] = []
    image2digest2pods[image_name][digest].append(pod)

# print(json.dumps(image2digest2pods, indent=4, default=str))

print("\nchecking remote repositories, fetching repodigest for images")

for image_name in image2digest2pods:
    print()
    print(image_name)

    host = namespace = repo = tag = ""
    repo, tag = image_name.rsplit(":", 1)
    if "/" in repo:
        namespace, repo = repo.rsplit("/", 1)
    if "/" in namespace:
        host, namespace = namespace.rsplit("/", 1)

    creds = ""
    for digest, pods in image2digest2pods[image_name].items():
        if creds: break
        for pod in pods:
            if creds: break
            pull_secrets = pod["spec"].get("imagePullSecrets", "null")
            if pull_secrets != "null":
                for pull_secret in pull_secrets:
                    token_name = pull_secret["name"]
                    token = kubectl.get("secret", token_name)
                    secret_base64 = token["data"].get(".dockerconfigjson", "")
                    if not secret_base64:
                        continue
                    secret_dict = json.loads(base64.b64decode(secret_base64))
                    hostname = list(secret_dict["auths"].keys())[0]
                    username = secret_dict["auths"][hostname]["username"]
                    password = secret_dict["auths"][hostname]["password"]
                    # print("pull secret found: using username {}".format(username))
                    creds="{}:{}".format(username, password)
                    break

    raw_result = subprocess.run(
        filter(None,
            ["skopeo", "inspect", "--creds={}".format(creds) if creds else None, "docker://{}/{}/{}:{}".format(
                host if host else "docker.io",
                namespace if namespace else "library",
                repo,
                tag
            )]
        ),
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE)
    repodigest = ""
    if raw_result.returncode == 0:
        result = json.loads(raw_result.stdout)
        repodigest = result["Digest"]
        # print(repodigest)
        for pod in image2digest2pods[image_name].get(repodigest, []):
            print("uptodate: pod/{}".format(pod["metadata"]["name"]))
        for digest in image2digest2pods.get(image_name, {}):
            if digest == repodigest:
                continue
            for pod in image2digest2pods[image_name][digest]:
                pod_name = pod["metadata"]["name"]
                print("outdated! pod/{}".format(pod_name))
                print("repodigest of pod: {}".format(digest))
                print("newest repodigest: {}".format(repodigest))

                pull_always = pod["status"]["containerStatuses"][0].get("imagePullPolicy") == "Always"
                tag_latest = image_name.endswith(":latest")
                if (pull_always or tag_latest):
                    kubectl.delete("pod", pod_name)
                else:
                    print("consider replacing it!")

    else:
        print("[WARN] {}".format(raw_result.stderr))
        continue

print("\ndone")
